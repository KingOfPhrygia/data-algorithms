{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Mklorum For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Home"},{"location":"#welcome-to-mklorum","text":"For full documentation visit mkdocs.org .","title":"Welcome to Mklorum"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"about/","text":"","title":"About"},{"location":"arrays/","text":"Arrays In Python, there is no built-in data structure called \"array\". However, the Python standard library provides a module called array that allows you to create arrays of numeric values. Creating an Array To create an array, you need to import the array module and call its array() function, passing in a type code and an iterable containing the initial values of the array. Here's an example: python Code import array Create an array of integers numbers = array.array('i', [1, 2, 3, 4, 5]) print(numbers) Output: array('i', [1, 2, 3, 4, 5]) Create an array of floats floats = array.array('f', [1.0, 2.0, 3.0, 4.0, 5.0]) print(floats) Output: array('f', [1.0, 2.0, 3.0, 4.0, 5.0]) The first argument to the array() function is a type code that specifies the data type of the elements in the array. For example, the 'i' type code indicates that the array contains integers, while the 'f' type code indicates that the array contains floats. You can find a list of type codes in the Python documentation. Accessing Elements You can access individual elements of an array using indexing, just like with a list. Here's an example: python Code numbers = array.array('i', [1, 2, 3, 4, 5]) print(numbers[0]) # Output: 1 print(numbers[2]) # Output: 3 Modifying Elements You can modify elements of an array using indexing and assignment. Here's an example: python Code numbers = array.array('i', [1, 2, 3, 4, 5]) numbers[0] = 10 numbers[2] = 30 print(numbers) # Output: array('i', [10, 2, 30, 4, 5]) Array Methods The array module provides several methods for manipulating arrays. Here are some of the most commonly used methods: append(x): Add an element x to the end of the array. extend(iterable): Append the elements from an iterable to the end of the array. insert(i, x): Insert an element x at position i. remove(x): Remove the first occurrence of element x from the array. pop(i): Remove and return the element at position i. index(x): Return the index of the first occurrence of element x. count(x): Return the number of occurrences of element x. reverse(): Reverse the order of the elements in the array. sort(): Sort the elements in the array. Conclusion Arrays are a data structure in Python that allow you to store collections of numeric values. They are similar to lists, but are more efficient for numerical computations. The array module provides a simple way to create and manipulate arrays in Python.","title":"arrays"},{"location":"arrays/#arrays","text":"In Python, there is no built-in data structure called \"array\". However, the Python standard library provides a module called array that allows you to create arrays of numeric values.","title":"Arrays"},{"location":"arrays/#creating-an-array","text":"To create an array, you need to import the array module and call its array() function, passing in a type code and an iterable containing the initial values of the array. Here's an example: python Code import array Create an array of integers numbers = array.array('i', [1, 2, 3, 4, 5]) print(numbers) Output: array('i', [1, 2, 3, 4, 5]) Create an array of floats floats = array.array('f', [1.0, 2.0, 3.0, 4.0, 5.0]) print(floats) Output: array('f', [1.0, 2.0, 3.0, 4.0, 5.0]) The first argument to the array() function is a type code that specifies the data type of the elements in the array. For example, the 'i' type code indicates that the array contains integers, while the 'f' type code indicates that the array contains floats. You can find a list of type codes in the Python documentation.","title":"Creating an Array"},{"location":"arrays/#accessing-elements","text":"You can access individual elements of an array using indexing, just like with a list. Here's an example: python Code numbers = array.array('i', [1, 2, 3, 4, 5]) print(numbers[0]) # Output: 1 print(numbers[2]) # Output: 3","title":"Accessing Elements"},{"location":"arrays/#modifying-elements","text":"You can modify elements of an array using indexing and assignment. Here's an example: python Code numbers = array.array('i', [1, 2, 3, 4, 5]) numbers[0] = 10 numbers[2] = 30 print(numbers) # Output: array('i', [10, 2, 30, 4, 5])","title":"Modifying Elements"},{"location":"arrays/#array-methods","text":"The array module provides several methods for manipulating arrays. Here are some of the most commonly used methods: append(x): Add an element x to the end of the array. extend(iterable): Append the elements from an iterable to the end of the array. insert(i, x): Insert an element x at position i. remove(x): Remove the first occurrence of element x from the array. pop(i): Remove and return the element at position i. index(x): Return the index of the first occurrence of element x. count(x): Return the number of occurrences of element x. reverse(): Reverse the order of the elements in the array. sort(): Sort the elements in the array.","title":"Array Methods"},{"location":"arrays/#conclusion","text":"Arrays are a data structure in Python that allow you to store collections of numeric values. They are similar to lists, but are more efficient for numerical computations. The array module provides a simple way to create and manipulate arrays in Python.","title":"Conclusion"},{"location":"graphs/","text":"Graphs Graphs are a type of non-linear data structure that consist of a set of vertices (also called nodes) and a set of edges that connect them. Graphs can be used to represent a wide range of relationships and connections between objects, such as social networks, transportation networks, and computer networks. Basic Terminology Before we dive into the different types of graphs and their operations, let's define some basic terminology: Vertex (or Node): A single element in the graph that represents an object. Edge: A connection between two vertices that represents a relationship or connection between the objects they represent. Degree: The number of edges incident to a vertex. Path: A sequence of vertices connected by edges. Cycle: A path that starts and ends at the same vertex. Connected: A graph is connected if there is a path between any two vertices in the graph. Weighted: A graph is weighted if each edge has a numerical weight or cost associated with it. Directed: A graph is directed if the edges have a direction, meaning that each edge goes from one vertex (the source) to another vertex (the destination). Types of Graphs There are several types of graphs, each with its own unique properties and algorithms: Undirected Graphs: A graph where each edge is bidirectional, meaning that you can travel from vertex A to vertex B and vice versa. In an undirected graph, the edges are represented as unordered pairs of vertices. Directed Graphs (Digraphs): A graph where each edge has a direction, meaning that you can travel from vertex A to vertex B but not necessarily from B to A. In a directed graph, the edges are represented as ordered pairs of vertices. Weighted Graphs: A graph where each edge has a numerical weight or cost associated with it. Weighted graphs are often used to model problems where there are costs or distances associated with traveling between vertices. Connected Graphs: A graph where there is a path between any two vertices in the graph. Connected graphs are often used to model networks where all the vertices are reachable from each other. Acyclic Graphs: A graph with no cycles, meaning that there is no path that starts and ends at the same vertex. Acyclic graphs are often used to model hierarchical relationships or dependencies between objects. Bipartite Graphs: A graph where the vertices can be partitioned into two sets such that all edges connect a vertex from one set to a vertex from the other set. Bipartite graphs are often used to model relationships between two distinct types of objects. Graph Operations There are several operations that can be performed on graphs, including: Insertion: Add a new vertex or edge to the graph. Traversal: Traverse the graph in a specific order, such as breadth-first or depth-first. Search: Find a specific vertex or edge in the graph. Shortest Path: Find the shortest path between two vertices in the graph. Minimum Spanning Tree: Find a tree that connects all the vertices in the graph with the minimum total weight. Conclusion Graphs are a powerful and flexible data structure that can be used to model a wide range of problems and relationships. Whether you're working with undirected graphs, directed graphs, weighted graphs, or any other type of graph, it's important to understand the basic terminology and operations that can be performed on them. By using graphs effectively, you can build efficient and elegant algorithms that solve complex problems.","title":"graphs"},{"location":"graphs/#graphs","text":"Graphs are a type of non-linear data structure that consist of a set of vertices (also called nodes) and a set of edges that connect them. Graphs can be used to represent a wide range of relationships and connections between objects, such as social networks, transportation networks, and computer networks.","title":"Graphs"},{"location":"graphs/#basic-terminology","text":"Before we dive into the different types of graphs and their operations, let's define some basic terminology: Vertex (or Node): A single element in the graph that represents an object. Edge: A connection between two vertices that represents a relationship or connection between the objects they represent. Degree: The number of edges incident to a vertex. Path: A sequence of vertices connected by edges. Cycle: A path that starts and ends at the same vertex. Connected: A graph is connected if there is a path between any two vertices in the graph. Weighted: A graph is weighted if each edge has a numerical weight or cost associated with it. Directed: A graph is directed if the edges have a direction, meaning that each edge goes from one vertex (the source) to another vertex (the destination).","title":"Basic Terminology"},{"location":"graphs/#types-of-graphs","text":"There are several types of graphs, each with its own unique properties and algorithms: Undirected Graphs: A graph where each edge is bidirectional, meaning that you can travel from vertex A to vertex B and vice versa. In an undirected graph, the edges are represented as unordered pairs of vertices. Directed Graphs (Digraphs): A graph where each edge has a direction, meaning that you can travel from vertex A to vertex B but not necessarily from B to A. In a directed graph, the edges are represented as ordered pairs of vertices. Weighted Graphs: A graph where each edge has a numerical weight or cost associated with it. Weighted graphs are often used to model problems where there are costs or distances associated with traveling between vertices. Connected Graphs: A graph where there is a path between any two vertices in the graph. Connected graphs are often used to model networks where all the vertices are reachable from each other. Acyclic Graphs: A graph with no cycles, meaning that there is no path that starts and ends at the same vertex. Acyclic graphs are often used to model hierarchical relationships or dependencies between objects. Bipartite Graphs: A graph where the vertices can be partitioned into two sets such that all edges connect a vertex from one set to a vertex from the other set. Bipartite graphs are often used to model relationships between two distinct types of objects.","title":"Types of Graphs"},{"location":"graphs/#graph-operations","text":"There are several operations that can be performed on graphs, including: Insertion: Add a new vertex or edge to the graph. Traversal: Traverse the graph in a specific order, such as breadth-first or depth-first. Search: Find a specific vertex or edge in the graph. Shortest Path: Find the shortest path between two vertices in the graph. Minimum Spanning Tree: Find a tree that connects all the vertices in the graph with the minimum total weight.","title":"Graph Operations"},{"location":"graphs/#conclusion","text":"Graphs are a powerful and flexible data structure that can be used to model a wide range of problems and relationships. Whether you're working with undirected graphs, directed graphs, weighted graphs, or any other type of graph, it's important to understand the basic terminology and operations that can be performed on them. By using graphs effectively, you can build efficient and elegant algorithms that solve complex problems.","title":"Conclusion"},{"location":"hash%20tables/","text":"Hash Tables Hash tables are a data structure that provides a way to store and retrieve key-value pairs. A hash table uses a hash function to map keys to indices in an array, where the corresponding values are stored. Hash tables are also sometimes referred to as hash maps, dictionaries, or associative arrays. Basic Terminology Before we dive into the implementation and usage of hash tables, let's define some basic terminology: Key: An identifier that is used to access a value in the hash table. Value: The data associated with a given key. Hash Function: A function that takes a key as input and returns an index in the hash table's array. Hash Collision: When two or more keys map to the same index in the hash table's array. Load Factor: The ratio of the number of items in the hash table to the size of the array. Implementation The implementation of a hash table typically involves the following steps: Create an array with a fixed size to store the key-value pairs. Implement a hash function that maps keys to indices in the array. Store the key-value pairs in the array by mapping each key to an index using the hash function. Handle hash collisions by resolving them with a collision resolution strategy, such as chaining or linear probing. Provide methods for inserting, retrieving, and deleting key-value pairs from the hash table. Operations on Hash Tables Hash tables support several operations that can be used to manipulate and retrieve data: Insert: Add a new key-value pair to the hash table. Retrieve: Get the value associated with a given key from the hash table. Delete: Remove a key-value pair from the hash table. Contains: Check if a given key is present in the hash table. Properties of Hash Tables Hash tables have several properties that make them useful in a variety of applications: Fast retrieval: Retrieving data from a hash table is typically faster than searching for it in an array or linked list, especially for large datasets. Efficient storage: Hash tables can store large amounts of data in a compact format, using only the space required to store the key-value pairs. Dynamic resizing: Hash tables can be resized dynamically as the number of items in the table grows, allowing them to adapt to changing requirements. Hash collisions: Handling hash collisions can be a challenge, but with the right collision resolution strategy, hash tables can still provide efficient retrieval of data. Conclusion Hash tables are a powerful data structure that provide an efficient way to store and retrieve key-value pairs. They are widely used in a variety of applications, including databases, web applications, and programming languages. By using hash tables effectively, you can simplify your code and improve the performance of your applications.","title":"hash tables"},{"location":"hash%20tables/#hash-tables","text":"Hash tables are a data structure that provides a way to store and retrieve key-value pairs. A hash table uses a hash function to map keys to indices in an array, where the corresponding values are stored. Hash tables are also sometimes referred to as hash maps, dictionaries, or associative arrays.","title":"Hash Tables"},{"location":"hash%20tables/#basic-terminology","text":"Before we dive into the implementation and usage of hash tables, let's define some basic terminology: Key: An identifier that is used to access a value in the hash table. Value: The data associated with a given key. Hash Function: A function that takes a key as input and returns an index in the hash table's array. Hash Collision: When two or more keys map to the same index in the hash table's array. Load Factor: The ratio of the number of items in the hash table to the size of the array.","title":"Basic Terminology"},{"location":"hash%20tables/#implementation","text":"The implementation of a hash table typically involves the following steps: Create an array with a fixed size to store the key-value pairs. Implement a hash function that maps keys to indices in the array. Store the key-value pairs in the array by mapping each key to an index using the hash function. Handle hash collisions by resolving them with a collision resolution strategy, such as chaining or linear probing. Provide methods for inserting, retrieving, and deleting key-value pairs from the hash table.","title":"Implementation"},{"location":"hash%20tables/#operations-on-hash-tables","text":"Hash tables support several operations that can be used to manipulate and retrieve data: Insert: Add a new key-value pair to the hash table. Retrieve: Get the value associated with a given key from the hash table. Delete: Remove a key-value pair from the hash table. Contains: Check if a given key is present in the hash table.","title":"Operations on Hash Tables"},{"location":"hash%20tables/#properties-of-hash-tables","text":"Hash tables have several properties that make them useful in a variety of applications: Fast retrieval: Retrieving data from a hash table is typically faster than searching for it in an array or linked list, especially for large datasets. Efficient storage: Hash tables can store large amounts of data in a compact format, using only the space required to store the key-value pairs. Dynamic resizing: Hash tables can be resized dynamically as the number of items in the table grows, allowing them to adapt to changing requirements. Hash collisions: Handling hash collisions can be a challenge, but with the right collision resolution strategy, hash tables can still provide efficient retrieval of data.","title":"Properties of Hash Tables"},{"location":"hash%20tables/#conclusion","text":"Hash tables are a powerful data structure that provide an efficient way to store and retrieve key-value pairs. They are widely used in a variety of applications, including databases, web applications, and programming languages. By using hash tables effectively, you can simplify your code and improve the performance of your applications.","title":"Conclusion"},{"location":"linked%20lists/","text":"linked list A linked list is a linear data structure in which each element, called a node, is linked to the next node using a pointer. The first node is called the head of the linked list, while the last node is called the tail. Here's an example of a simple linked list: Python code Head -> Node1 -> Node2 -> Node3 -> Tail Each node in a linked list consists of two parts: the data part and the next part. The data part contains the value of the node, while the next part contains a reference to the next node in the list. If the next part of a node is None, it means that it is the last node in the list. Creating a Linked List To create a linked list, you need to define a Node class that has two properties: data and next. Here's an example: Python code class Node: def init (self, data): self.data = data self.next = None The data property stores the value of the node, while the next property stores a reference to the next node in the list. The init () method initializes these properties to their default values. Once you have defined the Node class, you can create a linked list by creating the first node and setting the head of the list to that node. Here's an example: Python code Create the first node head = Node(1) Set the head of the list to the first node linked_list = head Adding Nodes To add a node to the end of a linked list, you need to traverse the list until you reach the tail, and then add the new node after the tail. Here's an example: Python code Traverse the list to find the tail current = linked_list while current.next is not None: current = current.next Add the new node after the tail new_node = Node(2) current.next = new_node To add a node to the beginning of a linked list, you simply set the next property of the new node to the current head of the list, and then set the head of the list to the new node. Here's an example: Python code Add a node to the beginning of the list new_node = Node(0) new_node.next = linked_list linked_list = new_node Removing Nodes To remove a node from a linked list, you need to find the node that precedes it, and then update the next property of that node to skip over the node to be removed. Here's an example: Python code Remove the second node from the list current = linked_list previous = None while current is not None and current.data != 2: previous = current current = current.next if current is not None: previous.next = current.next Traversing a Linked List To traverse a linked list, you start at the head of the list and follow the next property of each node until you reach the tail. Here's an example: Python code Traverse the list and print each node's data current = linked_list while current is not None: print(current.data) current = current.next Conclusion Linked lists are a powerful and flexible data structure in Python that allow you to store collections of elements in a specific order. They provide a simple way to add, remove, and traverse nodes in the list, making them a popular choice for many programming tasks.","title":"linked lists"},{"location":"linked%20lists/#linked-list","text":"A linked list is a linear data structure in which each element, called a node, is linked to the next node using a pointer. The first node is called the head of the linked list, while the last node is called the tail. Here's an example of a simple linked list: Python code Head -> Node1 -> Node2 -> Node3 -> Tail Each node in a linked list consists of two parts: the data part and the next part. The data part contains the value of the node, while the next part contains a reference to the next node in the list. If the next part of a node is None, it means that it is the last node in the list.","title":"linked list"},{"location":"linked%20lists/#creating-a-linked-list","text":"To create a linked list, you need to define a Node class that has two properties: data and next. Here's an example: Python code class Node: def init (self, data): self.data = data self.next = None The data property stores the value of the node, while the next property stores a reference to the next node in the list. The init () method initializes these properties to their default values. Once you have defined the Node class, you can create a linked list by creating the first node and setting the head of the list to that node. Here's an example: Python code Create the first node head = Node(1) Set the head of the list to the first node linked_list = head","title":"Creating a Linked List"},{"location":"linked%20lists/#adding-nodes","text":"To add a node to the end of a linked list, you need to traverse the list until you reach the tail, and then add the new node after the tail. Here's an example: Python code Traverse the list to find the tail current = linked_list while current.next is not None: current = current.next Add the new node after the tail new_node = Node(2) current.next = new_node To add a node to the beginning of a linked list, you simply set the next property of the new node to the current head of the list, and then set the head of the list to the new node. Here's an example: Python code Add a node to the beginning of the list new_node = Node(0) new_node.next = linked_list linked_list = new_node","title":"Adding Nodes"},{"location":"linked%20lists/#removing-nodes","text":"To remove a node from a linked list, you need to find the node that precedes it, and then update the next property of that node to skip over the node to be removed. Here's an example: Python code Remove the second node from the list current = linked_list previous = None while current is not None and current.data != 2: previous = current current = current.next if current is not None: previous.next = current.next","title":"Removing Nodes"},{"location":"linked%20lists/#traversing-a-linked-list","text":"To traverse a linked list, you start at the head of the list and follow the next property of each node until you reach the tail. Here's an example: Python code Traverse the list and print each node's data current = linked_list while current is not None: print(current.data) current = current.next","title":"Traversing a Linked List"},{"location":"linked%20lists/#conclusion","text":"Linked lists are a powerful and flexible data structure in Python that allow you to store collections of elements in a specific order. They provide a simple way to add, remove, and traverse nodes in the list, making them a popular choice for many programming tasks.","title":"Conclusion"},{"location":"lists/","text":"List A list is a data structure that stores a collection of elements in a specific order. The elements can be of any data type, including numbers, strings, and even other lists. In Python, lists are represented by square brackets [], and the elements are separated by commas. Creating a List To create a list in Python, you simply need to enclose a sequence of elements in square brackets, separated by commas. Here's an example: fruits = ['apple', 'banana', 'orange', 'grape'] Accessing Elements You can access elements in a list by their index, which starts at 0 for the first element. To access an element, simply use the index number in square brackets. Here's an example: print(fruits[0]) # Output: apple print(fruits[1]) # Output: banana print(fruits[-1]) # Output: grape You can also access a range of elements by specifying a starting and ending index, separated by a colon. This is called slicing. Here's an example: print(fruits[1:3]) # Output: ['banana', 'orange'] print(fruits[:2]) # Output: ['apple', 'banana'] print(fruits[2:]) # Output: ['orange', 'grape'] Modifying Elements You can modify elements in a list by assigning a new value to an index. Here's an example: fruits[0] = 'kiwi' print(fruits) # Output: ['kiwi', 'banana', 'orange', 'grape'] Adding Elements You can add elements to a list using the append() method, which adds an element to the end of the list. Here's an example: fruits.append('mango') print(fruits) # Output: ['kiwi', 'banana', 'orange', 'grape', 'mango'] You can also insert an element at a specific position using the insert() method. Here's an example: fruits.insert(2, 'peach') print(fruits) # Output: ['kiwi', 'banana', 'peach', 'orange', 'grape', 'mango'] Removing Elements You can remove an element from a list using the remove() method, which removes the first occurrence of the element. Here's an example: fruits.remove('banana') print(fruits) # Output: ['kiwi', 'peach', 'orange', 'grape', 'mango'] You can also remove an element at a specific position using the pop() method. Here's an example: fruits.pop(1) print(fruits) # Output: ['kiwi', 'orange', 'grape', 'mango'] List Length You can find the number of elements in a list using the len() function. Here's an example: print(len(fruits)) # Output: 4 Sorting a List You can sort the elements in a list using the sort() method. Here's an example: fruits.sort() print(fruits) # Output: ['grape', 'kiwi', 'mango', 'orange'] You can also sort the elements in reverse order using the reverse() method. Here's an example: fruits = ['orange', 'mango', 'kiwi', 'grape'] fruits.reverse() print(fruits) # Output: ['grape', 'kiwi', 'mango', 'orange'] Copying a List You can create a copy of a list using the copy() method or by slicing the entire list. Here's an example: Using the copy() method fruits_copy = fruits.copy() print(fruits_copy) # Output: ['orange', 'mango', 'kiwi', 'grape'] Using slicing fruits_copy2 = fruits[:] print(fruits_copy2) # Output: ['orange', 'mango', 'kiwi', 'grape'] Combining Lists You can combine two or more lists using the + operator. Here's an example: vegetables = ['carrot', 'spinach', 'cabbage'] fruits_and_veggies = fruits + vegetables print(fruits_and_veggies) # Output: ['orange', 'mango', 'kiwi', 'grape', 'carrot', 'spinach', 'cabbage'] List Comprehension List comprehension is a concise way of creating a new list based on an existing list. Here's an example: Create a new list containing the squares of the numbers in the original list numbers = [1, 2, 3, 4, 5] squares = [x**2 for x in numbers] print(squares) # Output: [1, 4, 9, 16, 25] Nested Lists A list can also contain other lists as elements. This is called a nested list. Here's an example: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] print(matrix[0][0]) # Output: 1 print(matrix[1][2]) # Output: 6 Conclusion Lists are a powerful and versatile data structure in Python that allow you to store collections of elements in a specific order. They provide a wide range of methods for accessing, modifying, and manipulating the elements, making them a popular choice for many programming tasks.","title":"List"},{"location":"lists/#list","text":"A list is a data structure that stores a collection of elements in a specific order. The elements can be of any data type, including numbers, strings, and even other lists. In Python, lists are represented by square brackets [], and the elements are separated by commas.","title":"List"},{"location":"lists/#creating-a-list","text":"To create a list in Python, you simply need to enclose a sequence of elements in square brackets, separated by commas. Here's an example: fruits = ['apple', 'banana', 'orange', 'grape']","title":"Creating a List"},{"location":"lists/#accessing-elements","text":"You can access elements in a list by their index, which starts at 0 for the first element. To access an element, simply use the index number in square brackets. Here's an example: print(fruits[0]) # Output: apple print(fruits[1]) # Output: banana print(fruits[-1]) # Output: grape You can also access a range of elements by specifying a starting and ending index, separated by a colon. This is called slicing. Here's an example: print(fruits[1:3]) # Output: ['banana', 'orange'] print(fruits[:2]) # Output: ['apple', 'banana'] print(fruits[2:]) # Output: ['orange', 'grape']","title":"Accessing Elements"},{"location":"lists/#modifying-elements","text":"You can modify elements in a list by assigning a new value to an index. Here's an example: fruits[0] = 'kiwi' print(fruits) # Output: ['kiwi', 'banana', 'orange', 'grape']","title":"Modifying Elements"},{"location":"lists/#adding-elements","text":"You can add elements to a list using the append() method, which adds an element to the end of the list. Here's an example: fruits.append('mango') print(fruits) # Output: ['kiwi', 'banana', 'orange', 'grape', 'mango'] You can also insert an element at a specific position using the insert() method. Here's an example: fruits.insert(2, 'peach') print(fruits) # Output: ['kiwi', 'banana', 'peach', 'orange', 'grape', 'mango']","title":"Adding Elements"},{"location":"lists/#removing-elements","text":"You can remove an element from a list using the remove() method, which removes the first occurrence of the element. Here's an example: fruits.remove('banana') print(fruits) # Output: ['kiwi', 'peach', 'orange', 'grape', 'mango'] You can also remove an element at a specific position using the pop() method. Here's an example: fruits.pop(1) print(fruits) # Output: ['kiwi', 'orange', 'grape', 'mango']","title":"Removing Elements"},{"location":"lists/#list-length","text":"You can find the number of elements in a list using the len() function. Here's an example: print(len(fruits)) # Output: 4","title":"List Length"},{"location":"lists/#sorting-a-list","text":"You can sort the elements in a list using the sort() method. Here's an example: fruits.sort() print(fruits) # Output: ['grape', 'kiwi', 'mango', 'orange'] You can also sort the elements in reverse order using the reverse() method. Here's an example: fruits = ['orange', 'mango', 'kiwi', 'grape'] fruits.reverse() print(fruits) # Output: ['grape', 'kiwi', 'mango', 'orange']","title":"Sorting a List"},{"location":"lists/#copying-a-list","text":"You can create a copy of a list using the copy() method or by slicing the entire list. Here's an example: Using the copy() method fruits_copy = fruits.copy() print(fruits_copy) # Output: ['orange', 'mango', 'kiwi', 'grape'] Using slicing fruits_copy2 = fruits[:] print(fruits_copy2) # Output: ['orange', 'mango', 'kiwi', 'grape']","title":"Copying a List"},{"location":"lists/#combining-lists","text":"You can combine two or more lists using the + operator. Here's an example: vegetables = ['carrot', 'spinach', 'cabbage'] fruits_and_veggies = fruits + vegetables print(fruits_and_veggies) # Output: ['orange', 'mango', 'kiwi', 'grape', 'carrot', 'spinach', 'cabbage']","title":"Combining Lists"},{"location":"lists/#list-comprehension","text":"List comprehension is a concise way of creating a new list based on an existing list. Here's an example: Create a new list containing the squares of the numbers in the original list numbers = [1, 2, 3, 4, 5] squares = [x**2 for x in numbers] print(squares) # Output: [1, 4, 9, 16, 25]","title":"List Comprehension"},{"location":"lists/#nested-lists","text":"A list can also contain other lists as elements. This is called a nested list. Here's an example: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] print(matrix[0][0]) # Output: 1 print(matrix[1][2]) # Output: 6","title":"Nested Lists"},{"location":"lists/#conclusion","text":"Lists are a powerful and versatile data structure in Python that allow you to store collections of elements in a specific order. They provide a wide range of methods for accessing, modifying, and manipulating the elements, making them a popular choice for many programming tasks.","title":"Conclusion"},{"location":"queues/","text":"Queue A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle, meaning that the first element added to the queue is the first one to be removed. It operates like a physical queue of people waiting in line, where the first person in line is the first one to be served and leave the line. In a queue, you can only access the front and rear elements. Any new elements added to the queue are added to the rear, and when you remove an element from the queue, it is always the front element that is removed. Here are some key operations that can be performed on a queue: Enqueue: Add an element to the rear of the queue. Dequeue: Remove the front element from the queue. Peek: Get the value of the front element without removing it from the queue. IsEmpty: Check if the queue is empty. Size: Get the number of elements in the queue. Queues are commonly used in programming for tasks such as processing tasks in the order they were received, implementing message queues, and more. Creating a Queue In Python, you can create a queue using a list. Here's an example: python code queue = [] Enqueuing Elements to the Queue To add an element to the rear of the queue, you can use the append() method on the list. Here's an example: python code queue.append(1) queue.append(2) queue.append(3) Now the queue contains the elements 1, 2, and 3, with 1 at the front and 3 at the rear. Dequeuing Elements from the Queue To remove the front element from the queue, you can use the pop(0) method on the list. Here's an example: python code front_element = queue.pop(0) print(front_element) # Output: 1 Now the queue contains the elements 2 and 3, with 2 at the front and 3 at the rear. Peeking at the Front Element To get the value of the front element without removing it from the queue, you can use indexing operator on the list. Here's an example: python code front_element = queue[0] print(front_element) # Output: 2 Checking if the Queue is Empty To check if the queue is empty, you can use the len() function on the list. Here's an example: python code if len(queue) == 0: print(\"Queue is empty\") else: print(\"Queue is not empty\") Getting the Size of the Queue To get the number of elements in the queue, you can use the len() function on the list. Here's an example: python code queue_size = len(queue) print(queue_size) # Output: 2 Conclusion Queues are a simple but powerful data structure in Python that allow you to add and remove elements in a specific order. They are commonly used in programming for a wide range of tasks, and can be implemented using a list in Python. Understanding how to use queues can help you write more efficient and elegant code.","title":"queues"},{"location":"queues/#queue","text":"A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle, meaning that the first element added to the queue is the first one to be removed. It operates like a physical queue of people waiting in line, where the first person in line is the first one to be served and leave the line. In a queue, you can only access the front and rear elements. Any new elements added to the queue are added to the rear, and when you remove an element from the queue, it is always the front element that is removed. Here are some key operations that can be performed on a queue: Enqueue: Add an element to the rear of the queue. Dequeue: Remove the front element from the queue. Peek: Get the value of the front element without removing it from the queue. IsEmpty: Check if the queue is empty. Size: Get the number of elements in the queue. Queues are commonly used in programming for tasks such as processing tasks in the order they were received, implementing message queues, and more.","title":"Queue"},{"location":"queues/#creating-a-queue","text":"In Python, you can create a queue using a list. Here's an example: python code queue = []","title":"Creating a Queue"},{"location":"queues/#enqueuing-elements-to-the-queue","text":"To add an element to the rear of the queue, you can use the append() method on the list. Here's an example: python code queue.append(1) queue.append(2) queue.append(3) Now the queue contains the elements 1, 2, and 3, with 1 at the front and 3 at the rear.","title":"Enqueuing Elements to the Queue"},{"location":"queues/#dequeuing-elements-from-the-queue","text":"To remove the front element from the queue, you can use the pop(0) method on the list. Here's an example: python code front_element = queue.pop(0) print(front_element) # Output: 1 Now the queue contains the elements 2 and 3, with 2 at the front and 3 at the rear.","title":"Dequeuing Elements from the Queue"},{"location":"queues/#peeking-at-the-front-element","text":"To get the value of the front element without removing it from the queue, you can use indexing operator on the list. Here's an example: python code front_element = queue[0] print(front_element) # Output: 2","title":"Peeking at the Front Element"},{"location":"queues/#checking-if-the-queue-is-empty","text":"To check if the queue is empty, you can use the len() function on the list. Here's an example: python code if len(queue) == 0: print(\"Queue is empty\") else: print(\"Queue is not empty\")","title":"Checking if the Queue is Empty"},{"location":"queues/#getting-the-size-of-the-queue","text":"To get the number of elements in the queue, you can use the len() function on the list. Here's an example: python code queue_size = len(queue) print(queue_size) # Output: 2","title":"Getting the Size of the Queue"},{"location":"queues/#conclusion","text":"Queues are a simple but powerful data structure in Python that allow you to add and remove elements in a specific order. They are commonly used in programming for a wide range of tasks, and can be implemented using a list in Python. Understanding how to use queues can help you write more efficient and elegant code.","title":"Conclusion"},{"location":"sets/","text":"Sets Sets are a type of collection data structure that represent a collection of distinct and unordered elements. In other words, sets are a way of representing a group of objects where order and duplicates don't matter. The elements in a set can be of any data type, such as integers, strings, or even other sets. Basic Terminology Before we dive into the operations and properties of sets, let's define some basic terminology: Element: A single object that belongs to a set. Membership: An element is said to be a member of a set if it belongs to that set. Cardinality: The number of elements in a set. Subset: A set A is a subset of another set B if every element in A is also in B. Union: The union of two sets A and B is the set of all elements that belong to either A or B, or both. Intersection: The intersection of two sets A and B is the set of all elements that belong to both A and B. Difference: The difference of two sets A and B is the set of all elements that belong to A but not B. Symmetric Difference: The symmetric difference of two sets A and B is the set of all elements that belong to either A or B, but not both. Operations on Sets Sets support several operations that can be used to manipulate and compare them: Add: Add a new element to the set. Remove: Remove an element from the set. Update: Update the set with the elements from another set or iterable. Clear: Remove all elements from the set. Membership: Check if an element belongs to the set. Size: Get the number of elements in the set. Subset: Check if one set is a subset of another set. Union: Get the union of two sets. Intersection: Get the intersection of two sets. Difference: Get the difference of two sets. Symmetric Difference: Get the symmetric difference of two sets. Properties of Sets Sets have several properties that make them useful in a variety of applications: Uniqueness: Sets can only contain unique elements, making them useful for filtering duplicates. Order independence: The order of elements in a set does not matter, making them useful for comparing groups of objects regardless of their order. Set operations: Sets support several set operations such as union, intersection, and difference, making them useful for performing set operations. Mathematical modeling: Sets are commonly used in mathematics to represent sets of numbers or other mathematical objects. Conclusion Sets are a useful data structure for representing collections of distinct and unordered elements. They support several operations for manipulating and comparing sets, and have properties such as uniqueness and order independence that make them useful in a variety of applications. By using sets effectively, you can simplify your code and solve complex problems with ease.","title":"sets"},{"location":"sets/#sets","text":"Sets are a type of collection data structure that represent a collection of distinct and unordered elements. In other words, sets are a way of representing a group of objects where order and duplicates don't matter. The elements in a set can be of any data type, such as integers, strings, or even other sets.","title":"Sets"},{"location":"sets/#basic-terminology","text":"Before we dive into the operations and properties of sets, let's define some basic terminology: Element: A single object that belongs to a set. Membership: An element is said to be a member of a set if it belongs to that set. Cardinality: The number of elements in a set. Subset: A set A is a subset of another set B if every element in A is also in B. Union: The union of two sets A and B is the set of all elements that belong to either A or B, or both. Intersection: The intersection of two sets A and B is the set of all elements that belong to both A and B. Difference: The difference of two sets A and B is the set of all elements that belong to A but not B. Symmetric Difference: The symmetric difference of two sets A and B is the set of all elements that belong to either A or B, but not both.","title":"Basic Terminology"},{"location":"sets/#operations-on-sets","text":"Sets support several operations that can be used to manipulate and compare them: Add: Add a new element to the set. Remove: Remove an element from the set. Update: Update the set with the elements from another set or iterable. Clear: Remove all elements from the set. Membership: Check if an element belongs to the set. Size: Get the number of elements in the set. Subset: Check if one set is a subset of another set. Union: Get the union of two sets. Intersection: Get the intersection of two sets. Difference: Get the difference of two sets. Symmetric Difference: Get the symmetric difference of two sets.","title":"Operations on Sets"},{"location":"sets/#properties-of-sets","text":"Sets have several properties that make them useful in a variety of applications: Uniqueness: Sets can only contain unique elements, making them useful for filtering duplicates. Order independence: The order of elements in a set does not matter, making them useful for comparing groups of objects regardless of their order. Set operations: Sets support several set operations such as union, intersection, and difference, making them useful for performing set operations. Mathematical modeling: Sets are commonly used in mathematics to represent sets of numbers or other mathematical objects.","title":"Properties of Sets"},{"location":"sets/#conclusion","text":"Sets are a useful data structure for representing collections of distinct and unordered elements. They support several operations for manipulating and comparing sets, and have properties such as uniqueness and order independence that make them useful in a variety of applications. By using sets effectively, you can simplify your code and solve complex problems with ease.","title":"Conclusion"},{"location":"stack/","text":"Stack A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle, meaning that the last element added to the stack is the first one to be removed. It operates like a physical stack of objects, where items are added and removed from the top. In a stack, you can only access the top element, and any new elements added to the stack are added to the top. When you remove an element from the stack, it is always the top element that is removed. Here are some key operations that can be performed on a stack: Push: Add an element to the top of the stack. Pop: Remove the top element from the stack. Peek: Get the value of the top element without removing it from the stack. IsEmpty: Check if the stack is empty. Size: Get the number of elements in the stack. Stacks are commonly used in programming for tasks such as maintaining a history of function calls, implementing undo/redo functionality, evaluating mathematical expressions, and more. Creating a Stack In Python, you can create a stack using a list. Here's an example: python code stack = [] Pushing Elements to the Stack To add an element to the top of the stack, you can use the append() method on the list. Here's an example: python code stack.append(1) stack.append(2) stack.append(3) Now the stack contains the elements 3, 2, and 1, with 3 at the top. Popping Elements from the Stack To remove the top element from the stack, you can use the pop() method on the list. Here's an example: python code top_element = stack.pop() print(top_element) # Output: 3 Now the stack contains the elements 2 and 1, with 2 at the top. Peeking at the Top Element To get the value of the top element without removing it from the stack, you can use the indexing operator on the list. Here's an example: python code top_element = stack[-1] print(top_element) # Output: 2 Checking if the Stack is Empty To check if the stack is empty, you can use the len() function on the list. Here's an example: python code if len(stack) == 0: print(\"Stack is empty\") else: print(\"Stack is not empty\") Getting the Size of the Stack To get the number of elements in the stack, you can use the len() function on the list. Here's an example: python code stack_size = len(stack) print(stack_size) # Output: 2 Conclusion Stacks are a simple but powerful data structure in Python that allow you to add and remove elements in a specific order. They are commonly used in programming for a wide range of tasks, and can be implemented using a list in Python. Understanding how to use stacks can help you write more efficient and elegant code.","title":"stack"},{"location":"stack/#stack","text":"A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle, meaning that the last element added to the stack is the first one to be removed. It operates like a physical stack of objects, where items are added and removed from the top. In a stack, you can only access the top element, and any new elements added to the stack are added to the top. When you remove an element from the stack, it is always the top element that is removed. Here are some key operations that can be performed on a stack: Push: Add an element to the top of the stack. Pop: Remove the top element from the stack. Peek: Get the value of the top element without removing it from the stack. IsEmpty: Check if the stack is empty. Size: Get the number of elements in the stack. Stacks are commonly used in programming for tasks such as maintaining a history of function calls, implementing undo/redo functionality, evaluating mathematical expressions, and more.","title":"Stack"},{"location":"stack/#creating-a-stack","text":"In Python, you can create a stack using a list. Here's an example: python code stack = []","title":"Creating a Stack"},{"location":"stack/#pushing-elements-to-the-stack","text":"To add an element to the top of the stack, you can use the append() method on the list. Here's an example: python code stack.append(1) stack.append(2) stack.append(3) Now the stack contains the elements 3, 2, and 1, with 3 at the top.","title":"Pushing Elements to the Stack"},{"location":"stack/#popping-elements-from-the-stack","text":"To remove the top element from the stack, you can use the pop() method on the list. Here's an example: python code top_element = stack.pop() print(top_element) # Output: 3 Now the stack contains the elements 2 and 1, with 2 at the top.","title":"Popping Elements from the Stack"},{"location":"stack/#peeking-at-the-top-element","text":"To get the value of the top element without removing it from the stack, you can use the indexing operator on the list. Here's an example: python code top_element = stack[-1] print(top_element) # Output: 2","title":"Peeking at the Top Element"},{"location":"stack/#checking-if-the-stack-is-empty","text":"To check if the stack is empty, you can use the len() function on the list. Here's an example: python code if len(stack) == 0: print(\"Stack is empty\") else: print(\"Stack is not empty\") Getting the Size of the Stack To get the number of elements in the stack, you can use the len() function on the list. Here's an example: python code stack_size = len(stack) print(stack_size) # Output: 2","title":"Checking if the Stack is Empty"},{"location":"stack/#conclusion","text":"Stacks are a simple but powerful data structure in Python that allow you to add and remove elements in a specific order. They are commonly used in programming for a wide range of tasks, and can be implemented using a list in Python. Understanding how to use stacks can help you write more efficient and elegant code.","title":"Conclusion"},{"location":"trees/","text":"Trees Trees are a type of non-linear data structure that consist of nodes connected by edges, where each node may have zero or more child nodes. The topmost node in a tree is called the root node, and every other node in the tree is either a parent node (with one or more child nodes) or a leaf node (with no child nodes). Trees are often used to represent hierarchical structures such as file systems, organization charts, and family trees. There are several types of trees, including binary trees, binary search trees, AVL trees, red-black trees, and many more. Each type of tree has its own unique properties and algorithms for searching, inserting, and deleting nodes. Basic Terminology Before we dive into the different types of trees, let's define some basic terminology: Node: A single element in the tree that contains data and zero or more child nodes. Root: The topmost node in the tree. Parent: A node that has one or more child nodes. Child: A node that is connected to its parent. Sibling: Nodes that share the same parent. Leaf: A node with no child nodes. Height: The number of edges on the longest path from a node to a leaf. Depth: The number of edges on the path from the root to a node. Binary Trees A binary tree is a tree data structure where each node has at most two child nodes, referred to as the left child and the right child. Binary trees are often used to implement binary search trees, where the values of nodes on the left side of a node are less than the node's value, and the values of nodes on the right side of a node are greater than the node's value. Here are some common operations that can be performed on a binary tree: Insertion: Add a new node to the tree. Traversal: Traverse the tree in a specific order, such as in-order, pre-order, or post-order. Search: Find a specific node in the tree. Deletion: Remove a node from the tree. AVL Trees An AVL tree is a self-balancing binary search tree where the heights of the two child subtrees of any node differ by at most one. AVL trees are named after their inventors, Adelson-Velsky and Landis. By maintaining the balance of the tree, AVL trees ensure that the search, insertion, and deletion operations can be performed in O(log n) time. Red-Black Trees A red-black tree is another type of self-balancing binary search tree where each node is colored either red or black. The root node and all leaf nodes are black, and if a node is red, then both of its child nodes are black. Red-black trees also ensure that the search, insertion, and deletion operations can be performed in O(log n) time. Conclusion Trees are a versatile and powerful data structure that are used in many applications across computer science. Whether you're working with binary trees, AVL trees, red-black trees, or any other type of tree, it's important to understand the basic terminology and operations that can be performed on them. By using trees effectively, you can build efficient and elegant algorithms that solve complex problems.","title":"trees"},{"location":"trees/#trees","text":"Trees are a type of non-linear data structure that consist of nodes connected by edges, where each node may have zero or more child nodes. The topmost node in a tree is called the root node, and every other node in the tree is either a parent node (with one or more child nodes) or a leaf node (with no child nodes). Trees are often used to represent hierarchical structures such as file systems, organization charts, and family trees. There are several types of trees, including binary trees, binary search trees, AVL trees, red-black trees, and many more. Each type of tree has its own unique properties and algorithms for searching, inserting, and deleting nodes.","title":"Trees"},{"location":"trees/#basic-terminology","text":"Before we dive into the different types of trees, let's define some basic terminology: Node: A single element in the tree that contains data and zero or more child nodes. Root: The topmost node in the tree. Parent: A node that has one or more child nodes. Child: A node that is connected to its parent. Sibling: Nodes that share the same parent. Leaf: A node with no child nodes. Height: The number of edges on the longest path from a node to a leaf. Depth: The number of edges on the path from the root to a node.","title":"Basic Terminology"},{"location":"trees/#binary-trees","text":"A binary tree is a tree data structure where each node has at most two child nodes, referred to as the left child and the right child. Binary trees are often used to implement binary search trees, where the values of nodes on the left side of a node are less than the node's value, and the values of nodes on the right side of a node are greater than the node's value. Here are some common operations that can be performed on a binary tree: Insertion: Add a new node to the tree. Traversal: Traverse the tree in a specific order, such as in-order, pre-order, or post-order. Search: Find a specific node in the tree. Deletion: Remove a node from the tree.","title":"Binary Trees"},{"location":"trees/#avl-trees","text":"An AVL tree is a self-balancing binary search tree where the heights of the two child subtrees of any node differ by at most one. AVL trees are named after their inventors, Adelson-Velsky and Landis. By maintaining the balance of the tree, AVL trees ensure that the search, insertion, and deletion operations can be performed in O(log n) time.","title":"AVL Trees"},{"location":"trees/#red-black-trees","text":"A red-black tree is another type of self-balancing binary search tree where each node is colored either red or black. The root node and all leaf nodes are black, and if a node is red, then both of its child nodes are black. Red-black trees also ensure that the search, insertion, and deletion operations can be performed in O(log n) time.","title":"Red-Black Trees"},{"location":"trees/#conclusion","text":"Trees are a versatile and powerful data structure that are used in many applications across computer science. Whether you're working with binary trees, AVL trees, red-black trees, or any other type of tree, it's important to understand the basic terminology and operations that can be performed on them. By using trees effectively, you can build efficient and elegant algorithms that solve complex problems.","title":"Conclusion"}]}